#!/bin/sh

set -o pipefail

is_restart_event=''
supervise_dir="/srv/storage/system/supervisor"

_supervisor_process()
{
  local package="`basename "$1"`"
  local service="`basename "$2"`"

  local pkg_supervise_dir="$supervise_dir/$package"
  local log="$pkg_supervise_dir/logs/$service.log"

  trap '_supervisor_resync_trap "$package" "$service"' HUP
  trap '_supervisor_restart_trap "$package" "$service"' USR1
  trap '_supervisor_termination_trap "$package" "$service"' TERM

  while true; do

    rm -f "$pkg_supervise_dir/status/$package.pid" &&
    mkdir -p "$pkg_supervise_dir/status" "$pkg_supervise_dir/logs"

    # Is service down?
    #   If so, block on the FIFO; a write is our signal to resume.
    
    local svc_down_fifo="$pkg_supervise_dir/status/$service.down"
    
    if [ -p "$svc_down_fifo" ]; then
      read < "$svc_down_fifo" &>/dev/null
      rm -f "$svc_down_fifo"
    fi
    
    # Fork-and-exec:
    #  This attempts to start the supervised process.
        
    (exec "/srv/scripts/$package/run/$service" >> "$log" 2>&1) &

    local pid="$!"
    local pid_file="$pkg_supervise_dir/status/$service.pid"
    
    echo "$pid" > "$pid_file" &&
    wait "$pid" &&
    rm -f "$pid_file"

    local status="$?"
    
    if [ "$status" -eq 0 ]; then
      echo "`date`: Service '$service' in package '$package'" \
        "exited normally (pid was '$pid')" >> "$log"
    else
      echo "`date`: Service '$service' in package '$package'" \
        "exited with non-zero status $status (pid was '$pid')" >> "$log"

      if [ "$is_restart_event" ]; then
        is_restart_event=''
      else
        sleep 5
      fi
    fi

    echo "`date`: Restarting service '$service' in '$package'" >> "$log"
  done
}

_supervisor_termination_trap()
{
  local package="$1"
  local service="$2"

  _supervisor_terminate_service "$package" "$service"
  exit 111
}

_supervisor_restart_trap()
{
  local package="$1"
  local service="$2"

  is_restart_event='true'
  _supervisor_terminate_service "$package" "$service"
}

_supervisor_resync_trap()
{
  local package="$1"
  local service="$2"

  local pkg_supervise_dir="$supervise_dir/$package"
  local svc_down_fifo="$pkg_supervise_dir/status/$service.down"

  if supervisor_is_service_running "$package" "$service"; then
    if [ -p "$svc_down_fifo" ]; then
      _supervisor_terminate_service "$package" "$service"
    fi
  fi
  
  return 0
}

_start_supervisor_process()
{
  local package="$1"
  local service="$2"

  local ppid_dir="$supervise_dir/$package/status"
  local ppid_file="$ppid_dir/$service.ppid"

  if supervisor_is_service_watched "$package" "$service"; then
    return 1
  fi
    
  trap '_terminate_supervisor_process "$package" "$service"' TERM

  _supervisor_process "$package" "$service" &>/dev/null &

  local pid="$!"
  mkdir -p "$ppid_dir" &&
  echo "$pid" > "$ppid_file"
  
  return "$?"
}

_terminate_supervisor_process()
{
  local package="$1"
  local service="$2"
  
  local ppid_file="$supervise_dir/$package/status/$service.ppid"
  
  if ! supervisor_is_service_watched "$package" "$service"; then
    return 1
  fi
  
  local ppid="`cat "$ppid_file" 2>/dev/null`" &&
  rm -f "$ppid_file" &&
  kill -TERM "$ppid" 2>/dev/null
  
  return "$?"
}

_pidfile_has_active_process()
{
  local pid_file="$1"
  
  if ! [ -f "$pid_file" ]; then
    return 1
  fi

  local pid="`cat "$pid_file" 2>/dev/null`"

  if ! [ -d "/proc/$pid" ]; then
    return 2
  fi

  return 0
}

_supervisor_terminate_service()
{
  local package="$1"
  local service="$2"

  local pkg_supervise_dir="$supervise_dir/$package"
  local pid="`cat "$pkg_supervise_dir/status/$service.pid" 2>/dev/null`"
  
  rm -f "$pkg_supervise_dir/status/$service.pid" &&
  kill -TERM "$pid" 2>/dev/null
}

_supervisor_apply()
{
  local operation="$1"
  local function="$2"
  local package="`basename "$3"`"
  shift 3
  
  local rv='0'
  local services="$@"

  if ! [ -d "/srv/scripts/$package" ]; then
    warn "Unable to locate package '$package'"
    return 255
  fi
  
  if [ "$#" -le 0 ]; then
    services="/srv/scripts/$package/run"/*
  fi

  for service in $services; do
  
    service="`basename "$service"`"
    
    if [ "$#" -le 0 -a "$service" = '*' ]; then
      warn "Unable to locate any services for package '$package'"
      return 255
    fi

    if ! [ -x "/srv/scripts/$package/run/$service" ]; then
      warn "Unable to locate service '$package/$service'"
      return 255
    fi
    
    "$function" "$package" "$service"
      
    if [ "$?" -ne 0 ]; then
      rv="$(($rv + 1))"
      warn "Failed to $operation supervisor for '$package/$service'"
    fi
  done

  return "$rv"
}

supervisor_start()
{
  _supervisor_apply 'start' _start_supervisor_process "$@"
  return "$?"
}

supervisor_stop()
{
  _supervisor_apply 'stop' _terminate_supervisor_process "$@"
  return "$?"
}

supervisor_reset()
{
  if [ -d "$supervise_dir" ]; then
    find "$supervise_dir" \( -type p -a -name '*.down' \) \
	-o -name '*.pid' -o -name '*.ppid' -exec rm -f {} \;
  fi

  return 0
}

supervisor_service_down()
{
  local package="`basename "$1"`"
  local service="`basename "$2"`"

  if ! supervisor_is_service_watched "$package" "$service"; then
    return 1 # Supervisor not running
  fi
  
  if supervisor_is_service_down "$package" "$service"; then
    return 2 # Service is already down
  fi

  local pkg_supervise_dir="$supervise_dir/$package"
  local ppid="`cat "$pkg_supervise_dir/status/$service.ppid"`"
  local svc_down_fifo="$pkg_supervise_dir/status/$service.down"
  
  rm -f "$svc_down_fifo" && mkfifo -m 0600 "$svc_down_fifo" &&
  kill -HUP "$ppid" 2>/dev/null
  
  if [ "$?" -ne 0 ]; then
    return 3 # FIFO / signal failure
  fi
    
  return 0 # Success
}

supervisor_service_up()
{
  local package="`basename "$1"`"
  local service="`basename "$2"`"

  if ! supervisor_is_service_watched "$package" "$service"; then
    return 1 # Supervisor not running
  fi

  if ! supervisor_is_service_down "$package" "$service"; then
    return 2 # Service is already up
  fi
 
  # Write to the FIFO:
  #   This unblocks `_supervisor_process` and starts the service.
  
  local pkg_supervise_dir="$supervise_dir/$package"
  local svc_down_fifo="$pkg_supervise_dir/status/$service.down"

  echo '1' > "$svc_down_fifo" || return 3
  return 0
}

supervisor_service_restart()
{
  local package="`basename "$1"`"
  local service="`basename "$2"`"

  if ! supervisor_is_service_watched "$package" "$service"; then
    return 1 # Supervisor not running
  fi
  
  if supervisor_is_service_down "$package" "$service"; then
    return 2 # Service is down
  fi

  if ! supervisor_is_service_running "$package" "$service"; then
    return 3 # Service is already starting
  fi

  local pkg_supervise_dir="$supervise_dir/$package"
  local ppid="`cat "$pkg_supervise_dir/status/$service.ppid"`"

  kill -USR1 "$ppid" 2>/dev/null

  if [ "$?" -ne 0 ]; then
    return 4 # Signal failure
  fi

  return 0 # Success
}

supervisor_service_reload()
{
  local package="`basename "$1"`"
  local service="$2"

  if ! supervisor_is_service_running "$package" "$service"; then
    return 1 # Service is down or currently starting
  fi

  local pkg_supervise_dir="$supervise_dir/$package"
  local pid="`cat "$pkg_supervise_dir/status/$service.pid"`"

  kill -HUP "$pid" 2>/dev/null

  if [ "$?" -ne 0 ]; then
    return 2 # Signal failure
  fi

  return 0 # Success
}

supervisor_list_all_packages()
{
  for package in "/srv/scripts"/*; do
    package="`basename "$package"`"
    if [ "$package" != '*' -a "$package" != 'system' ]; then
      echo "$package"
    fi
  done
  
  return 0
}

supervisor_list_all_services()
{
  local package="`basename "$1"`"

  for service in "/srv/scripts/$package/run"/*; do
    service="`basename "$service"`"
    if [ "$service" != '*' ]; then
      echo "$service"
    fi
  done

  return 0
}

supervisor_list_services_filtered()
{
  local package="`basename "$1"`"
  shift 1
  
  supervisor_list_all_services "$package" | while read service; do
    if "$@" "$package" "$service"; then
      echo "$service"
    fi
  done

  return 0
}

supervisor_list_expected_services()
{
  local package="`basename "$1"`"

  supervisor_list_services_filtered \
    "$package" supervisor_is_service_expected
}

supervisor_list_down_services()
{
  local package="`basename "$1"`"
  
  supervisor_list_services_filtered \
    "$package" supervisor_is_service_down
}

supervisor_list_watched_services()
{
  local package="`basename "$1"`"

  # List services where supervisor is running:
  #   Loop over control data to avoid iterating through everything.
  
  for service in "$supervise_dir/$package/status"/*.ppid; do
    service="`basename "$service" .ppid`"
    if [ "$service" != '*' ]; then
      if supervisor_is_service_watched "$package" "$service"; then
        echo "$service"
      fi
    fi
  done

  return 0
}

supervisor_list_running_services()
{
  local package="`basename "$1"`"

  # List services where intended process is running:
  #   Loop over control data to avoid iterating through everything.
  
  for service in "$supervise_dir/$package/status"/*.pid; do
    service="`basename "$service" .pid`"
    if [ "$service" != '*' ]; then
      if supervisor_is_service_running "$package" "$service"; then
      	echo "$service"
      fi
    fi
  done

  return 0
}

supervisor_is_service_watched()
{
  local package="`basename "$1"`"
  local service="`basename "$2"`"
  
  _pidfile_has_active_process \
    "$supervise_dir/$package/status/$service.ppid"
}

supervisor_is_service_running()
{
  local package="`basename "$1"`"
  local service="`basename "$2"`"

  _pidfile_has_active_process \
    "$supervise_dir/$package/status/$service.pid"
}

supervisor_is_service_down()
{
  local package="`basename "$1"`"
  local service="`basename "$2"`"

  [ -p "$supervise_dir/$package/status/$service.down" ]
}

supervisor_is_service_expected()
{
  supervisor_is_service_down "$@"
  [ "$?" -ne 0 ]
}

